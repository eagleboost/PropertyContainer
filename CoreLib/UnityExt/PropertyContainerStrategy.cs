namespace CoreLib.UnityExt
{
  using CoreLib.Extensions;
  using Unity;
  using Unity.Builder;
  using Unity.Strategies;

  /// <summary>
  /// PropertyContainerStrategy
  /// </summary>
  public class PropertyContainerStrategy : BuilderStrategy
  {
    private readonly IUnityContainer _container;

    public PropertyContainerStrategy(IUnityContainer container)
    {
      _container = container;
    }
    
    public override void PreBuildUp(ref BuilderContext context)
    {
      base.PreBuildUp(ref context);

      var type = context.Type;
      if (_container.IsRegistered(type))
      {
        ////Do nothing if the type is already registered, aka Container.RegisterType() is called for the type
        return;
      }

      if (type.IsSubclassOf<IPropertyContainerMarker>())
      {
        ////Do nothing if the type is already generated by PropertyContainerImpl
        return;
      }
      
      ////We use PropertyContainerTypeKey<T> as the key to determine whether a class need this auto generated class or not 
      if (_container.IsRegistered(typeof(PropertyContainerTypeKey<>).MakeGenericType(type)))
      {
        var implType = PropertyContainerImpl.GetImplType(type);
        context.Type = implType;
        ////Register to map the original type to the generated type so next time when resolving the same type again 
        ////container would return the registration so this line of check would return directly
        //// if (type.IsSubclassOf<IPropertyContainerMarker>()) return;
        _container.RegisterType(type, implType);
      }
    }
  }
}